<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

</style>
<script src="/js/jquery-1.10.2.min.js"></script>
<script src="/js/utils.js"></script>
</head>
<body>

<script src="/js/d3.v3.js"></script>

<div style="position:absolute;left-margin:10px;"><table id="legend" border="1"></table></div>
<center><div id="graph"></div></center>
<div id="entry_text"></div>

<script>

var width = 625;
var height = 625;

var color = d3.scale.category10();
var unselected = "#cdc9c9";

var feedNames = [
  'BostonHerald',
  'ChicagoTribune',
  'DailyNews',
  'LATimes',
  'NYPost',
  'NYTimes',
  'StLouisPost',
  'USAToday',
  'WallStreetJournal',
  'WashingtonPost'
];

var selectedFeed = [];
for (var i in feedNames) {
  selectedFeed.push(true);
}

var force = d3.layout.force()
  .charge(-120)
  .linkDistance(30)
  .size([width, height]);

var svg = d3.select("#graph").append("svg")
  .attr("width", width)
  .attr("height", height);

// svg
//   .style("float", "left")
//   .transition()
//   .duration(2000)
//   .style("float", "center");

var viz = svg.append("g").attr("id", "viz");
var legend = svg.append("g").attr("id", "legend");

svg
  .append("rect")
  .attr("id", "svg_border")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", width)
  .attr("height", height)
  .style("stroke", "black")
  .style("fill", "none")
  .style("stroke-width", 1);
  
var currentData = null;
var linkDistanceRatio = (width > height? height : width) / (2 + 1);

var link, node, graph_backup;

d3.json("/data/dists_graph_" + getQS("entry") + ".json", function(error, graph) {
  if (error) throw error;

  for (var l in graph['links']){
    l = graph['links'][l];
    l['feed_source'] = graph['nodes'][l['source']].feedname;
    l['feed_target'] = graph['nodes'][l['target']].feedname;
  }

  // Build this backup since we will be modifying graph
  graph_backup = {};
  
  for (var cat in graph){
    graph_backup[cat] = [];
    for (var g in graph[cat])
      graph_backup[cat].push(graph[cat][g]);
  }

  force
    .nodes(graph.nodes)
    .links(graph.links)
    .linkDistance(function(d){ return d.value * linkDistanceRatio; })
    .start();

  link = viz.selectAll(".link")
    .data(graph.links)
    .enter().append("line")
    .attr("class", "link")
    .style("stroke-width", function (d) {
      var x = (1 - d.value) * 1.5;
      return x > 1 ? 1 : x;
    });

  node = viz.selectAll(".node")
    .data(graph.nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", function(d) { return 3 + 10 * d.closeness; })
    .attr("fill", function(d) { return color(d.feedname); })
    .attr("fill-opacity", 0.75)
    .call(force.drag)
    .on("mouseover", function(d){
      if (selectedFeed[d.feedname]){
        $("#entry_text").html(d.title);

        d3.select(this)
          .transition()
          .duration(200)
          .attr("r", function(d) { return 8 + 10 * d.closeness; })
          .attr("fill-opacity", 1.);
      }
    })
    .on("mouseout", function(d){
      if (selectedFeed[d.feedname]){
        $("#entry_text").html("");

        d3.select(this)
          .transition()
          .duration(200)
          .attr("r", function(d) { return 3 + 10 * d.closeness; })
          .attr("fill-opacity", 0.75);
      }
    });

  node.append("title")
    .text(function(d) { return d.name + ': ' + d.title; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

    node
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
  });  
});

  // Legend item (individual boxes + label)

  function changeGraph(feed_d, i) {
    selectedFeed[i] = !selectedFeed[i];
    var newNode = selectedFeed[i];

    legend
      .selectAll('rect.legendSq')
      .transition()
      .duration(newNode ? 1000: 500)
      .style("fill", function(d, i2) {
          return selectedFeed[i2] ? color(i2): unselected;
      });

    node
      .transition()
      .duration(newNode ? 1000: 500)
      .attr("fill", function(d) {
        return selectedFeed[d.feedname] ? color(d.feedname): unselected;
      })
      .attr("fill-opacity", function(d) {
        return selectedFeed[d.feedname] ? 0.75: 0.25;
      })
      .attr("r", function(d) {
        return selectedFeed[d.feedname] ? (3 + 10 * d.closeness): 2;    
      });

    link
      .transition()
      .duration(newNode ? 1000: 500)
      .style("stroke-width", function (d) {
        var x = (1 - d.value) * 1.5;
        return (
          selectedFeed[d.feed_source] && selectedFeed[d.feed_target]
        ) ? (x > 1 ? 1 : x) : 0;
      });
  }

  function legendMouse(over, feed_d, i) {
    legend
      .selectAll('rect.legendSq')
      .transition()
      .duration(over ? 1000: 500)
      .style("fill", function(d, i2) {
          return (over && i2 == i) || (!over && selectedFeed[i2]) ? color(i2): unselected;
      });

    node
      .transition()
      .duration(over ? 1000: 500)
      .attr("fill", function(d) {
        if (over)
          return d.feedname == i ? color(d.feedname) : unselected; 
        else
          return selectedFeed[d.feedname] ? color(d.feedname): unselected;
      })
      .attr("fill-opacity", function(d) {
        if (over)
          return d.feedname == i? 1. : 0.25; 
        else
          return selectedFeed[d.feedname] ? 0.75: 0.25; 
      })
      .attr("r", function(d) {
        if (over)
          return d.feedname == i? (8 + 10 * d.closeness): 5;
        else
          return selectedFeed[d.feedname] ? (3 + 10 * d.closeness): 2;
      });

    link
      .transition()
      .duration(over ? 1000: 500)
      .style("stroke-width", function (d) {
        var x = (1 - d.value) * 1.5;
        return (
          ((over && d.feed_source == i) || selectedFeed[d.feed_source]) &&
          ((over && d.feed_target == i) || selectedFeed[d.feed_target])
        ) ? (x > 1 ? 1 : x) : 0;
      });
  }

  legend
    .append('rect')
    .attr("id", "legendRect")
    .attr("fill", "white")
    .attr("stroke-width", "0.5px")
    .attr("stroke", "#000000");

  legend
    .selectAll('rect')
    .data(feedNames, function(d){ return d; })
    .enter()
    .append('rect')
    .attr("class", "legendSq")
    .attr("x", width + 15)
    .attr("y", function(d, i){ return height + 5 + i * 17; })
    .attr("width", 10)
    .attr("height", 10)
    .attr("fill", function(d, i){ return d3.rgb(color(i)); })
    .style("cursor", "pointer")
    .on("click", changeGraph)
    .on("mouseover", function(d, i) { return legendMouse(true, d, i); })
    .on("mouseout", function(d, i) { return legendMouse(false, d, i); });

  legend
    .selectAll('text')
    .data(feedNames, function(d){ return d; })
    .enter()
    .append("text")
    .attr("class", "legendText")
    .text(function(d, i){ return d; })
    .attr("x", width + 15 + 10 + 5)
    .attr("y", function(d, i){ return height + 5 + i * 17 + 5; })
    .attr("font-size", "12px")
    .attr("font-family", "sans-serif")
    .attr("fill", "black")
    .style("cursor", "pointer")
    .on("click", changeGraph)
    .on("mouseover", function(d, i) { return legendMouse(true, d, i); })
    .on("mouseout", function(d, i) { return legendMouse(false, d, i); });

  var legendWidth = legend.node().getBBox().width + 15 + 10 + 5;
  var legendHeight = legend.node().getBBox().height + 5 + 5;

  legend
    .select("#legendRect")
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .attr("x", width - legendWidth)
    .attr("y", height - legendHeight);

  legend
    .selectAll(".legendSq")
    .attr("x", width - legendWidth + 15)
    .attr("y", function(d, i){ return height - legendHeight + 5 + i * 17; });

  legend
    .selectAll(".legendText")
    .attr("x", width + 15 + 10 + 5 - legendWidth)
    .attr("y", function(d, i){ return height - legendHeight + 5 + i * 17 + 9; });

</script>